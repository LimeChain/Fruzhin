package com.limechain.rpc.pubsub.subscriberchannel;

import com.limechain.rpc.pubsub.Message;
import com.limechain.rpc.pubsub.PubSubService;
import com.limechain.rpc.pubsub.Topic;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.java.Log;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;

/**
 * Subscriber channels are the entities who aggregate messages for a topic and propagate them to subscribers.
 */
@Getter
@Setter
@Log
public abstract class AbstractSubscriberChannel {

    /**
     * Holds the topic for the channel
     */
    private final Topic topic;

    /**
     * The subscribers which will be notified. For now it's just a WebSocketSession.
     * <p>
     * In the future, WebSocketSession will probably be replaced with a standalone subscriber class
     * which will hold more complicated business logic such as keeping a mapping of each session
     * to its subscriber ids generated by the services
     *
     * @see <a href="https://paritytech.github.io/json-rpc-interface-spec/api/chainHead_unstable_follow.html#usage">
     * subscription id usage</a>
     */
    private final List<WebSocketSession> subscribers = new ArrayList<>();

    /**
     * Messages that will be sent to subscribers at some point
     */
    private final List<Message> pendingMessages = new ArrayList<>();

    public AbstractSubscriberChannel(Topic topic) {
        this.topic = topic;
    }

    /**
     * Adds a subscriber to the channel
     *
     * @param session the subscriber to add
     */
    public abstract void addSubscriber(WebSocketSession session);

    /**
     * Removes a subscriber from the channel
     *
     * @param session the subscriber to remove
     */
    public abstract void removeSubscriber(WebSocketSession session);

    /**
     * Request messages for this channel from {@link PubSubService}
     *
     * @param pubSubService the pub-sub service mediator
     */
    public abstract void getMessagesForSubscriberOfTopic(PubSubService pubSubService);

    /**
     * Send all messages from {@link #pendingMessages} to every subscriber from {@link #subscribers}
     *
     * @throws IOException when subscriber(session) fails to send the message to the client
     */
    public synchronized void notifySubscribers() throws IOException {
        log.log(Level.FINE, "Sending messages to subscribers...");
        // What happens if PubSubService tries to add new messages while we're in the for loop?
        // Option 1. Messages get added normally (highly unlikely since there's no lock on subscriberMessages)
        // Option 2. Messages get added and processed on the next run of printMessages
        // Option 3. Messages get added but overwritten by new ArrayList<>() at the end of this function
        // Option 4. Option 2 and 3 depending on the timing
        for (Message message : pendingMessages) {
            TextMessage wsMessage = new TextMessage(message.payload().getBytes());
            log.log(Level.FINE,
                    "Notifying " + subscribers.size() + " subscribers about message topic -> " + message.topic() +
                            " : " +
                            message.payload());
            for (WebSocketSession session : subscribers) {
                session.sendMessage(wsMessage);
            }
        }
        // Empty the pending messages
        this.getPendingMessages().clear();
    }
}

