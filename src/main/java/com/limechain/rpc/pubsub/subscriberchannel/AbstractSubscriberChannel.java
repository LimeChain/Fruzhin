package com.limechain.rpc.pubsub.subscriberchannel;

import com.limechain.rpc.pubsub.Message;
import com.limechain.rpc.pubsub.Topic;
import com.limechain.utils.HashUtils;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.java.Log;
import org.apache.tomcat.util.buf.HexUtils;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;

/**
 * Subscriber channels are the entities who aggregate messages for a topic and propagate them to subscribers.
 */
@Getter
@Setter
@Log
public abstract class AbstractSubscriberChannel {

    private static final String SUBSCRIPTION_ID_PREFIX = "fruzhin_sub_";
    private static long lastSubscriptionId = 0;

    /**
     * Holds the topic for the channel
     */
    private final Topic topic;
    /**
     * The subscribers which will be notified. For now it's just a WebSocketSession.
     * <p>
     * In the future, WebSocketSession will probably be replaced with a standalone subscriber class
     * which will hold more complicated business logic such as keeping a mapping of each session
     * to its subscriber ids generated by the services
     *
     * @see <a href="https://paritytech.github.io/json-rpc-interface-spec/api/chainHead_unstable_follow.html#usage">
     * subscription id usage</a>
     */
    private final Map<String, Subscriber> subscribers = new HashMap<>();

    /**
     * Messages that will be sent to subscribers at some point
     */
    private final List<Message> pendingMessages = new ArrayList<>();

    protected AbstractSubscriberChannel(Topic topic) {
        this.topic = topic;
    }

    protected static String generateSubscriptionId() {
        byte[] subId = (SUBSCRIPTION_ID_PREFIX + lastSubscriptionId++).getBytes();
        return HexUtils.toHexString(HashUtils.hashXx64(0, subId));
    }

    /**
     * Adds a subscriber to the channel
     *
     * @param session the subscriber to add
     * @return the subscription id
     */
    public abstract Subscriber addSubscriber(WebSocketSession session);

    /**
     * Removes a subscriber from the channel
     *
     * @param subId the subscription id of the subscriber to remove
     */
    public abstract void removeSubscriber(String subId);

    /**
     * Adds a message to the channel
     *
     * @param message the message to add
     */
    public abstract void addMessage(Message message);

    /**
     * Send all messages from {@link #pendingMessages} to every subscriber from {@link #subscribers}
     *
     * @throws IOException when subscriber(session) fails to send the message to the client
     */
    public synchronized void notifySubscribers() throws IOException {
        log.log(Level.FINE, "Sending messages to subscribers...");
        // What happens if PubSubService tries to add new messages while we're in the for loop?
        // Option 1. Messages get added normally (highly unlikely since there's no lock on subscriberMessages)
        // Option 2. Messages get added and processed on the next run of printMessages
        // Option 3. Messages get added but overwritten by new ArrayList<>() at the end of this function
        // Option 4. Option 2 and 3 depending on the timing
        for (Message message : pendingMessages) {
            TextMessage wsMessage = new TextMessage(message.payload().getBytes());
            log.log(Level.FINE,
                    "Notifying " + subscribers.size() + " subscribers about message topic -> " + message.topic() +
                    " : " + message.payload());
            for (Subscriber subscriber : subscribers.values()) {
                subscriber.getSession().sendMessage(wsMessage);
            }
        }
        // Empty the pending messages
        this.getPendingMessages().clear();
    }
}

